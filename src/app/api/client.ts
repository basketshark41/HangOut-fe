//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class Client {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param currentUserId (optional) 
     * @return OK
     */
    conversationsGET(id: number, currentUserId: number | undefined): Observable<ConversationDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Conversations/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (currentUserId === null)
            throw new Error("The parameter 'currentUserId' cannot be null.");
        else if (currentUserId !== undefined)
            url_ += "currentUserId=" + encodeURIComponent("" + currentUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConversationsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConversationsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConversationDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConversationDtoApiResponseDto>;
        }));
    }

    protected processConversationsGET(response: HttpResponseBase): Observable<ConversationDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConversationDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param searchTerm (optional) 
     * @param sortBy (optional) 
     * @param sortDescending (optional) 
     * @return OK
     */
    user(userId: number, page: number | undefined, pageSize: number | undefined, searchTerm: string | undefined, sortBy: string | undefined, sortDescending: boolean | undefined): Observable<ConversationSummaryDtoPagedResultDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Conversations/user/{userId}?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDescending === null)
            throw new Error("The parameter 'sortDescending' cannot be null.");
        else if (sortDescending !== undefined)
            url_ += "SortDescending=" + encodeURIComponent("" + sortDescending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConversationSummaryDtoPagedResultDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConversationSummaryDtoPagedResultDtoApiResponseDto>;
        }));
    }

    protected processUser(response: HttpResponseBase): Observable<ConversationSummaryDtoPagedResultDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConversationSummaryDtoPagedResultDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param creatorId (optional) 
     * @param body (optional) 
     * @return OK
     */
    conversationsPOST(creatorId: number | undefined, body: CreateConversationDto | undefined): Observable<ConversationDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Conversations?";
        if (creatorId === null)
            throw new Error("The parameter 'creatorId' cannot be null.");
        else if (creatorId !== undefined)
            url_ += "creatorId=" + encodeURIComponent("" + creatorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConversationsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConversationsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConversationDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConversationDtoApiResponseDto>;
        }));
    }

    protected processConversationsPOST(response: HttpResponseBase): Observable<ConversationDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConversationDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId1 (optional) 
     * @param userId2 (optional) 
     * @return OK
     */
    private(userId1: number | undefined, userId2: number | undefined): Observable<ConversationDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Conversations/private?";
        if (userId1 === null)
            throw new Error("The parameter 'userId1' cannot be null.");
        else if (userId1 !== undefined)
            url_ += "userId1=" + encodeURIComponent("" + userId1) + "&";
        if (userId2 === null)
            throw new Error("The parameter 'userId2' cannot be null.");
        else if (userId2 !== undefined)
            url_ += "userId2=" + encodeURIComponent("" + userId2) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConversationDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConversationDtoApiResponseDto>;
        }));
    }

    protected processPrivate(response: HttpResponseBase): Observable<ConversationDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConversationDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param currentUserId (optional) 
     * @return OK
     */
    participantsPOST(id: number, userId: number | undefined, currentUserId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Conversations/{id}/participants?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (currentUserId === null)
            throw new Error("The parameter 'currentUserId' cannot be null.");
        else if (currentUserId !== undefined)
            url_ += "currentUserId=" + encodeURIComponent("" + currentUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processParticipantsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processParticipantsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processParticipantsPOST(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currentUserId (optional) 
     * @return OK
     */
    participantsDELETE(id: number, userId: number, currentUserId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Conversations/{id}/participants/{userId}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (currentUserId === null)
            throw new Error("The parameter 'currentUserId' cannot be null.");
        else if (currentUserId !== undefined)
            url_ += "currentUserId=" + encodeURIComponent("" + currentUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processParticipantsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processParticipantsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processParticipantsDELETE(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @return OK
     */
    leave(id: number, userId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Conversations/{id}/leave?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLeave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLeave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processLeave(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @return OK
     */
    read(id: number, userId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Conversations/{id}/read?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processRead(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @return OK
     */
    unreadCount(id: number, userId: number | undefined): Observable<Int32ApiResponseDto> {
        let url_ = this.baseUrl + "/api/Conversations/{id}/unread-count?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnreadCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnreadCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int32ApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int32ApiResponseDto>;
        }));
    }

    protected processUnreadCount(response: HttpResponseBase): Observable<Int32ApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32ApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currentUserId (optional) 
     * @return OK
     */
    eventsGET(id: number, currentUserId: number | undefined): Observable<EventDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Events/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (currentUserId === null)
            throw new Error("The parameter 'currentUserId' cannot be null.");
        else if (currentUserId !== undefined)
            url_ += "currentUserId=" + encodeURIComponent("" + currentUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEventsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventDtoApiResponseDto>;
        }));
    }

    protected processEventsGET(response: HttpResponseBase): Observable<EventDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currentUserId (optional) 
     * @param body (optional) 
     * @return OK
     */
    eventsPUT(id: number, currentUserId: number | undefined, body: UpdateEventDto | undefined): Observable<EventDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Events/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (currentUserId === null)
            throw new Error("The parameter 'currentUserId' cannot be null.");
        else if (currentUserId !== undefined)
            url_ += "currentUserId=" + encodeURIComponent("" + currentUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEventsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventDtoApiResponseDto>;
        }));
    }

    protected processEventsPUT(response: HttpResponseBase): Observable<EventDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currentUserId (optional) 
     * @return OK
     */
    eventsDELETE(id: number, currentUserId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Events/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (currentUserId === null)
            throw new Error("The parameter 'currentUserId' cannot be null.");
        else if (currentUserId !== undefined)
            url_ += "currentUserId=" + encodeURIComponent("" + currentUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEventsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processEventsDELETE(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param searchTerm (optional) 
     * @param sortBy (optional) 
     * @param sortDescending (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param eventTypeIds (optional) 
     * @param maxCost (optional) 
     * @param location (optional) 
     * @param radius (optional) 
     * @param userLatitude (optional) 
     * @param userLongitude (optional) 
     * @param friendsOnly (optional) 
     * @param status (optional) 
     * @return OK
     */
    eventsGET2(page: number | undefined, pageSize: number | undefined, searchTerm: string | undefined, sortBy: string | undefined, sortDescending: boolean | undefined, startDate: Date | undefined, endDate: Date | undefined, eventTypeIds: number[] | undefined, maxCost: number | undefined, location: string | undefined, radius: number | undefined, userLatitude: number | undefined, userLongitude: number | undefined, friendsOnly: boolean | undefined, status: string | undefined): Observable<EventSummaryDtoPagedResultDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Events?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDescending === null)
            throw new Error("The parameter 'sortDescending' cannot be null.");
        else if (sortDescending !== undefined)
            url_ += "SortDescending=" + encodeURIComponent("" + sortDescending) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (eventTypeIds === null)
            throw new Error("The parameter 'eventTypeIds' cannot be null.");
        else if (eventTypeIds !== undefined)
            eventTypeIds && eventTypeIds.forEach(item => { url_ += "EventTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (maxCost === null)
            throw new Error("The parameter 'maxCost' cannot be null.");
        else if (maxCost !== undefined)
            url_ += "MaxCost=" + encodeURIComponent("" + maxCost) + "&";
        if (location === null)
            throw new Error("The parameter 'location' cannot be null.");
        else if (location !== undefined)
            url_ += "Location=" + encodeURIComponent("" + location) + "&";
        if (radius === null)
            throw new Error("The parameter 'radius' cannot be null.");
        else if (radius !== undefined)
            url_ += "Radius=" + encodeURIComponent("" + radius) + "&";
        if (userLatitude === null)
            throw new Error("The parameter 'userLatitude' cannot be null.");
        else if (userLatitude !== undefined)
            url_ += "UserLatitude=" + encodeURIComponent("" + userLatitude) + "&";
        if (userLongitude === null)
            throw new Error("The parameter 'userLongitude' cannot be null.");
        else if (userLongitude !== undefined)
            url_ += "UserLongitude=" + encodeURIComponent("" + userLongitude) + "&";
        if (friendsOnly === null)
            throw new Error("The parameter 'friendsOnly' cannot be null.");
        else if (friendsOnly !== undefined)
            url_ += "FriendsOnly=" + encodeURIComponent("" + friendsOnly) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEventsGET2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventsGET2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventSummaryDtoPagedResultDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventSummaryDtoPagedResultDtoApiResponseDto>;
        }));
    }

    protected processEventsGET2(response: HttpResponseBase): Observable<EventSummaryDtoPagedResultDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventSummaryDtoPagedResultDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param creatorId (optional) 
     * @param body (optional) 
     * @return OK
     */
    eventsPOST(creatorId: number | undefined, body: CreateEventDto | undefined): Observable<EventDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Events?";
        if (creatorId === null)
            throw new Error("The parameter 'creatorId' cannot be null.");
        else if (creatorId !== undefined)
            url_ += "creatorId=" + encodeURIComponent("" + creatorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEventsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventDtoApiResponseDto>;
        }));
    }

    protected processEventsPOST(response: HttpResponseBase): Observable<EventDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param searchTerm (optional) 
     * @param sortBy (optional) 
     * @param sortDescending (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param eventTypeIds (optional) 
     * @param maxCost (optional) 
     * @param location (optional) 
     * @param radius (optional) 
     * @param userLatitude (optional) 
     * @param userLongitude (optional) 
     * @param friendsOnly (optional) 
     * @param status (optional) 
     * @return OK
     */
    upcoming(page: number | undefined, pageSize: number | undefined, searchTerm: string | undefined, sortBy: string | undefined, sortDescending: boolean | undefined, startDate: Date | undefined, endDate: Date | undefined, eventTypeIds: number[] | undefined, maxCost: number | undefined, location: string | undefined, radius: number | undefined, userLatitude: number | undefined, userLongitude: number | undefined, friendsOnly: boolean | undefined, status: string | undefined): Observable<EventSummaryDtoPagedResultDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Events/upcoming?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDescending === null)
            throw new Error("The parameter 'sortDescending' cannot be null.");
        else if (sortDescending !== undefined)
            url_ += "SortDescending=" + encodeURIComponent("" + sortDescending) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (eventTypeIds === null)
            throw new Error("The parameter 'eventTypeIds' cannot be null.");
        else if (eventTypeIds !== undefined)
            eventTypeIds && eventTypeIds.forEach(item => { url_ += "EventTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (maxCost === null)
            throw new Error("The parameter 'maxCost' cannot be null.");
        else if (maxCost !== undefined)
            url_ += "MaxCost=" + encodeURIComponent("" + maxCost) + "&";
        if (location === null)
            throw new Error("The parameter 'location' cannot be null.");
        else if (location !== undefined)
            url_ += "Location=" + encodeURIComponent("" + location) + "&";
        if (radius === null)
            throw new Error("The parameter 'radius' cannot be null.");
        else if (radius !== undefined)
            url_ += "Radius=" + encodeURIComponent("" + radius) + "&";
        if (userLatitude === null)
            throw new Error("The parameter 'userLatitude' cannot be null.");
        else if (userLatitude !== undefined)
            url_ += "UserLatitude=" + encodeURIComponent("" + userLatitude) + "&";
        if (userLongitude === null)
            throw new Error("The parameter 'userLongitude' cannot be null.");
        else if (userLongitude !== undefined)
            url_ += "UserLongitude=" + encodeURIComponent("" + userLongitude) + "&";
        if (friendsOnly === null)
            throw new Error("The parameter 'friendsOnly' cannot be null.");
        else if (friendsOnly !== undefined)
            url_ += "FriendsOnly=" + encodeURIComponent("" + friendsOnly) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpcoming(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpcoming(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventSummaryDtoPagedResultDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventSummaryDtoPagedResultDtoApiResponseDto>;
        }));
    }

    protected processUpcoming(response: HttpResponseBase): Observable<EventSummaryDtoPagedResultDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventSummaryDtoPagedResultDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param searchTerm (optional) 
     * @param sortBy (optional) 
     * @param sortDescending (optional) 
     * @return OK
     */
    byCreator(creatorId: number, page: number | undefined, pageSize: number | undefined, searchTerm: string | undefined, sortBy: string | undefined, sortDescending: boolean | undefined): Observable<EventSummaryDtoPagedResultDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Events/by-creator/{creatorId}?";
        if (creatorId === undefined || creatorId === null)
            throw new Error("The parameter 'creatorId' must be defined.");
        url_ = url_.replace("{creatorId}", encodeURIComponent("" + creatorId));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDescending === null)
            throw new Error("The parameter 'sortDescending' cannot be null.");
        else if (sortDescending !== undefined)
            url_ += "SortDescending=" + encodeURIComponent("" + sortDescending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processByCreator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processByCreator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventSummaryDtoPagedResultDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventSummaryDtoPagedResultDtoApiResponseDto>;
        }));
    }

    protected processByCreator(response: HttpResponseBase): Observable<EventSummaryDtoPagedResultDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventSummaryDtoPagedResultDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param searchTerm (optional) 
     * @param sortBy (optional) 
     * @param sortDescending (optional) 
     * @return OK
     */
    user2(userId: number, page: number | undefined, pageSize: number | undefined, searchTerm: string | undefined, sortBy: string | undefined, sortDescending: boolean | undefined): Observable<EventSummaryDtoPagedResultDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Events/user/{userId}?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDescending === null)
            throw new Error("The parameter 'sortDescending' cannot be null.");
        else if (sortDescending !== undefined)
            url_ += "SortDescending=" + encodeURIComponent("" + sortDescending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUser2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUser2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventSummaryDtoPagedResultDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventSummaryDtoPagedResultDtoApiResponseDto>;
        }));
    }

    protected processUser2(response: HttpResponseBase): Observable<EventSummaryDtoPagedResultDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventSummaryDtoPagedResultDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param searchTerm (optional) 
     * @param sortBy (optional) 
     * @param sortDescending (optional) 
     * @return OK
     */
    friends(userId: number, page: number | undefined, pageSize: number | undefined, searchTerm: string | undefined, sortBy: string | undefined, sortDescending: boolean | undefined): Observable<EventSummaryDtoPagedResultDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Events/friends/{userId}?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDescending === null)
            throw new Error("The parameter 'sortDescending' cannot be null.");
        else if (sortDescending !== undefined)
            url_ += "SortDescending=" + encodeURIComponent("" + sortDescending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFriends(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFriends(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventSummaryDtoPagedResultDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventSummaryDtoPagedResultDtoApiResponseDto>;
        }));
    }

    protected processFriends(response: HttpResponseBase): Observable<EventSummaryDtoPagedResultDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventSummaryDtoPagedResultDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currentUserId (optional) 
     * @return OK
     */
    publish(id: number, currentUserId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Events/{id}/publish?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (currentUserId === null)
            throw new Error("The parameter 'currentUserId' cannot be null.");
        else if (currentUserId !== undefined)
            url_ += "currentUserId=" + encodeURIComponent("" + currentUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processPublish(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currentUserId (optional) 
     * @return OK
     */
    cancel(id: number, currentUserId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Events/{id}/cancel?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (currentUserId === null)
            throw new Error("The parameter 'currentUserId' cannot be null.");
        else if (currentUserId !== undefined)
            url_ += "currentUserId=" + encodeURIComponent("" + currentUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currentUserId (optional) 
     * @return OK
     */
    complete(id: number, currentUserId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Events/{id}/complete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (currentUserId === null)
            throw new Error("The parameter 'currentUserId' cannot be null.");
        else if (currentUserId !== undefined)
            url_ += "currentUserId=" + encodeURIComponent("" + currentUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComplete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processComplete(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param searchTerm (optional) 
     * @param sortBy (optional) 
     * @param sortDescending (optional) 
     * @return OK
     */
    participantsGET(id: number, page: number | undefined, pageSize: number | undefined, searchTerm: string | undefined, sortBy: string | undefined, sortDescending: boolean | undefined): Observable<ParticipationSummaryDtoPagedResultDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Events/{id}/participants?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDescending === null)
            throw new Error("The parameter 'sortDescending' cannot be null.");
        else if (sortDescending !== undefined)
            url_ += "SortDescending=" + encodeURIComponent("" + sortDescending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processParticipantsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processParticipantsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ParticipationSummaryDtoPagedResultDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ParticipationSummaryDtoPagedResultDtoApiResponseDto>;
        }));
    }

    protected processParticipantsGET(response: HttpResponseBase): Observable<ParticipationSummaryDtoPagedResultDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParticipationSummaryDtoPagedResultDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @return OK
     */
    canEdit(id: number, userId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Events/{id}/can-edit?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCanEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCanEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processCanEdit(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    eventTypesGET(id: number): Observable<EventTypeDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/EventTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEventTypesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventTypesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventTypeDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventTypeDtoApiResponseDto>;
        }));
    }

    protected processEventTypesGET(response: HttpResponseBase): Observable<EventTypeDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventTypeDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    eventTypesPUT(id: number, body: UpdateEventTypeDto | undefined): Observable<EventTypeDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/EventTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEventTypesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventTypesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventTypeDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventTypeDtoApiResponseDto>;
        }));
    }

    protected processEventTypesPUT(response: HttpResponseBase): Observable<EventTypeDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventTypeDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    eventTypesDELETE(id: number): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/EventTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEventTypesDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventTypesDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processEventTypesDELETE(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param searchTerm (optional) 
     * @param sortBy (optional) 
     * @param sortDescending (optional) 
     * @return OK
     */
    eventTypesGET2(page: number | undefined, pageSize: number | undefined, searchTerm: string | undefined, sortBy: string | undefined, sortDescending: boolean | undefined): Observable<EventTypeDtoPagedResultDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/EventTypes?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDescending === null)
            throw new Error("The parameter 'sortDescending' cannot be null.");
        else if (sortDescending !== undefined)
            url_ += "SortDescending=" + encodeURIComponent("" + sortDescending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEventTypesGET2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventTypesGET2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventTypeDtoPagedResultDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventTypeDtoPagedResultDtoApiResponseDto>;
        }));
    }

    protected processEventTypesGET2(response: HttpResponseBase): Observable<EventTypeDtoPagedResultDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventTypeDtoPagedResultDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    eventTypesPOST(body: CreateEventTypeDto | undefined): Observable<EventTypeDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/EventTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEventTypesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventTypesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventTypeDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventTypeDtoApiResponseDto>;
        }));
    }

    protected processEventTypesPOST(response: HttpResponseBase): Observable<EventTypeDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventTypeDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param searchTerm (optional) 
     * @param sortBy (optional) 
     * @param sortDescending (optional) 
     * @return OK
     */
    active(page: number | undefined, pageSize: number | undefined, searchTerm: string | undefined, sortBy: string | undefined, sortDescending: boolean | undefined): Observable<EventTypeDtoPagedResultDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/EventTypes/active?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDescending === null)
            throw new Error("The parameter 'sortDescending' cannot be null.");
        else if (sortDescending !== undefined)
            url_ += "SortDescending=" + encodeURIComponent("" + sortDescending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventTypeDtoPagedResultDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventTypeDtoPagedResultDtoApiResponseDto>;
        }));
    }

    protected processActive(response: HttpResponseBase): Observable<EventTypeDtoPagedResultDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventTypeDtoPagedResultDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    activate(id: number): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/EventTypes/{id}/activate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deactivate(id: number): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/EventTypes/{id}/deactivate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeactivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeactivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processDeactivate(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param searchTerm (optional) 
     * @param sortBy (optional) 
     * @param sortDescending (optional) 
     * @return OK
     */
    friends2(userId: number, page: number | undefined, pageSize: number | undefined, searchTerm: string | undefined, sortBy: string | undefined, sortDescending: boolean | undefined): Observable<FriendDtoPagedResultDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Friendships/user/{userId}/friends?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDescending === null)
            throw new Error("The parameter 'sortDescending' cannot be null.");
        else if (sortDescending !== undefined)
            url_ += "SortDescending=" + encodeURIComponent("" + sortDescending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFriends2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFriends2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FriendDtoPagedResultDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FriendDtoPagedResultDtoApiResponseDto>;
        }));
    }

    protected processFriends2(response: HttpResponseBase): Observable<FriendDtoPagedResultDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FriendDtoPagedResultDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param searchTerm (optional) 
     * @param sortBy (optional) 
     * @param sortDescending (optional) 
     * @return OK
     */
    pending(userId: number, page: number | undefined, pageSize: number | undefined, searchTerm: string | undefined, sortBy: string | undefined, sortDescending: boolean | undefined): Observable<FriendRequestDtoPagedResultDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Friendships/user/{userId}/requests/pending?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDescending === null)
            throw new Error("The parameter 'sortDescending' cannot be null.");
        else if (sortDescending !== undefined)
            url_ += "SortDescending=" + encodeURIComponent("" + sortDescending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPending(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPending(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FriendRequestDtoPagedResultDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FriendRequestDtoPagedResultDtoApiResponseDto>;
        }));
    }

    protected processPending(response: HttpResponseBase): Observable<FriendRequestDtoPagedResultDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FriendRequestDtoPagedResultDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param searchTerm (optional) 
     * @param sortBy (optional) 
     * @param sortDescending (optional) 
     * @return OK
     */
    sent(userId: number, page: number | undefined, pageSize: number | undefined, searchTerm: string | undefined, sortBy: string | undefined, sortDescending: boolean | undefined): Observable<FriendRequestDtoPagedResultDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Friendships/user/{userId}/requests/sent?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDescending === null)
            throw new Error("The parameter 'sortDescending' cannot be null.");
        else if (sortDescending !== undefined)
            url_ += "SortDescending=" + encodeURIComponent("" + sortDescending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FriendRequestDtoPagedResultDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FriendRequestDtoPagedResultDtoApiResponseDto>;
        }));
    }

    protected processSent(response: HttpResponseBase): Observable<FriendRequestDtoPagedResultDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FriendRequestDtoPagedResultDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param requesterId (optional) 
     * @param body (optional) 
     * @return OK
     */
    requests(requesterId: number | undefined, body: CreateFriendshipRequestDto | undefined): Observable<FriendshipDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Friendships/requests?";
        if (requesterId === null)
            throw new Error("The parameter 'requesterId' cannot be null.");
        else if (requesterId !== undefined)
            url_ += "requesterId=" + encodeURIComponent("" + requesterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequests(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FriendshipDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FriendshipDtoApiResponseDto>;
        }));
    }

    protected processRequests(response: HttpResponseBase): Observable<FriendshipDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FriendshipDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currentUserId (optional) 
     * @return OK
     */
    accept(friendshipId: number, currentUserId: number | undefined): Observable<FriendshipDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Friendships/requests/{friendshipId}/accept?";
        if (friendshipId === undefined || friendshipId === null)
            throw new Error("The parameter 'friendshipId' must be defined.");
        url_ = url_.replace("{friendshipId}", encodeURIComponent("" + friendshipId));
        if (currentUserId === null)
            throw new Error("The parameter 'currentUserId' cannot be null.");
        else if (currentUserId !== undefined)
            url_ += "currentUserId=" + encodeURIComponent("" + currentUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccept(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccept(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FriendshipDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FriendshipDtoApiResponseDto>;
        }));
    }

    protected processAccept(response: HttpResponseBase): Observable<FriendshipDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FriendshipDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currentUserId (optional) 
     * @return OK
     */
    decline(friendshipId: number, currentUserId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Friendships/requests/{friendshipId}/decline?";
        if (friendshipId === undefined || friendshipId === null)
            throw new Error("The parameter 'friendshipId' must be defined.");
        url_ = url_.replace("{friendshipId}", encodeURIComponent("" + friendshipId));
        if (currentUserId === null)
            throw new Error("The parameter 'currentUserId' cannot be null.");
        else if (currentUserId !== undefined)
            url_ += "currentUserId=" + encodeURIComponent("" + currentUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDecline(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDecline(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processDecline(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currentUserId (optional) 
     * @return OK
     */
    block(friendshipId: number, currentUserId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Friendships/{friendshipId}/block?";
        if (friendshipId === undefined || friendshipId === null)
            throw new Error("The parameter 'friendshipId' must be defined.");
        url_ = url_.replace("{friendshipId}", encodeURIComponent("" + friendshipId));
        if (currentUserId === null)
            throw new Error("The parameter 'currentUserId' cannot be null.");
        else if (currentUserId !== undefined)
            url_ += "currentUserId=" + encodeURIComponent("" + currentUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBlock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBlock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processBlock(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currentUserId (optional) 
     * @return OK
     */
    unblock(friendshipId: number, currentUserId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Friendships/{friendshipId}/unblock?";
        if (friendshipId === undefined || friendshipId === null)
            throw new Error("The parameter 'friendshipId' must be defined.");
        url_ = url_.replace("{friendshipId}", encodeURIComponent("" + friendshipId));
        if (currentUserId === null)
            throw new Error("The parameter 'currentUserId' cannot be null.");
        else if (currentUserId !== undefined)
            url_ += "currentUserId=" + encodeURIComponent("" + currentUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnblock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnblock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processUnblock(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currentUserId (optional) 
     * @return OK
     */
    friendships(friendshipId: number, currentUserId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Friendships/{friendshipId}?";
        if (friendshipId === undefined || friendshipId === null)
            throw new Error("The parameter 'friendshipId' must be defined.");
        url_ = url_.replace("{friendshipId}", encodeURIComponent("" + friendshipId));
        if (currentUserId === null)
            throw new Error("The parameter 'currentUserId' cannot be null.");
        else if (currentUserId !== undefined)
            url_ += "currentUserId=" + encodeURIComponent("" + currentUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFriendships(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFriendships(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processFriendships(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId1 (optional) 
     * @param userId2 (optional) 
     * @return OK
     */
    status(userId1: number | undefined, userId2: number | undefined): Observable<StringApiResponseDto> {
        let url_ = this.baseUrl + "/api/Friendships/status?";
        if (userId1 === null)
            throw new Error("The parameter 'userId1' cannot be null.");
        else if (userId1 !== undefined)
            url_ += "userId1=" + encodeURIComponent("" + userId1) + "&";
        if (userId2 === null)
            throw new Error("The parameter 'userId2' cannot be null.");
        else if (userId2 !== undefined)
            url_ += "userId2=" + encodeURIComponent("" + userId2) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringApiResponseDto>;
        }));
    }

    protected processStatus(response: HttpResponseBase): Observable<StringApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId1 (optional) 
     * @param userId2 (optional) 
     * @return OK
     */
    areFriends(userId1: number | undefined, userId2: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Friendships/are-friends?";
        if (userId1 === null)
            throw new Error("The parameter 'userId1' cannot be null.");
        else if (userId1 !== undefined)
            url_ += "userId1=" + encodeURIComponent("" + userId1) + "&";
        if (userId2 === null)
            throw new Error("The parameter 'userId2' cannot be null.");
        else if (userId2 !== undefined)
            url_ += "userId2=" + encodeURIComponent("" + userId2) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAreFriends(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAreFriends(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processAreFriends(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId1 (optional) 
     * @param userId2 (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param searchTerm (optional) 
     * @param sortBy (optional) 
     * @param sortDescending (optional) 
     * @return OK
     */
    mutual(userId1: number | undefined, userId2: number | undefined, page: number | undefined, pageSize: number | undefined, searchTerm: string | undefined, sortBy: string | undefined, sortDescending: boolean | undefined): Observable<UserDtoPagedResultDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Friendships/mutual?";
        if (userId1 === null)
            throw new Error("The parameter 'userId1' cannot be null.");
        else if (userId1 !== undefined)
            url_ += "userId1=" + encodeURIComponent("" + userId1) + "&";
        if (userId2 === null)
            throw new Error("The parameter 'userId2' cannot be null.");
        else if (userId2 !== undefined)
            url_ += "userId2=" + encodeURIComponent("" + userId2) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDescending === null)
            throw new Error("The parameter 'sortDescending' cannot be null.");
        else if (sortDescending !== undefined)
            url_ += "SortDescending=" + encodeURIComponent("" + sortDescending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMutual(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMutual(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoPagedResultDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoPagedResultDtoApiResponseDto>;
        }));
    }

    protected processMutual(response: HttpResponseBase): Observable<UserDtoPagedResultDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResultDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchTermQuery (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param searchTermQuery (optional) 
     * @param sortBy (optional) 
     * @param sortDescending (optional) 
     * @return OK
     */
    search(userId: number, searchTermQuery: string | undefined, page: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortDescending: boolean | undefined): Observable<UserDtoPagedResultDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Friendships/user/{userId}/search?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (searchTermQuery === null)
            throw new Error("The parameter 'searchTermQuery' cannot be null.");
        else if (searchTermQuery !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTermQuery) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTermQuery === null)
            throw new Error("The parameter 'searchTermQuery' cannot be null.");
        else if (searchTermQuery !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTermQuery) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDescending === null)
            throw new Error("The parameter 'sortDescending' cannot be null.");
        else if (sortDescending !== undefined)
            url_ += "SortDescending=" + encodeURIComponent("" + sortDescending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoPagedResultDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoPagedResultDtoApiResponseDto>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<UserDtoPagedResultDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResultDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currentUserId (optional) 
     * @return OK
     */
    messagesGET(id: number, currentUserId: number | undefined): Observable<MessageDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Messages/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (currentUserId === null)
            throw new Error("The parameter 'currentUserId' cannot be null.");
        else if (currentUserId !== undefined)
            url_ += "currentUserId=" + encodeURIComponent("" + currentUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMessagesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMessagesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MessageDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MessageDtoApiResponseDto>;
        }));
    }

    protected processMessagesGET(response: HttpResponseBase): Observable<MessageDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currentUserId (optional) 
     * @param body (optional) 
     * @return OK
     */
    messagesPUT(id: number, currentUserId: number | undefined, body: UpdateMessageDto | undefined): Observable<MessageDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Messages/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (currentUserId === null)
            throw new Error("The parameter 'currentUserId' cannot be null.");
        else if (currentUserId !== undefined)
            url_ += "currentUserId=" + encodeURIComponent("" + currentUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMessagesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMessagesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MessageDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MessageDtoApiResponseDto>;
        }));
    }

    protected processMessagesPUT(response: HttpResponseBase): Observable<MessageDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currentUserId (optional) 
     * @return OK
     */
    messagesDELETE(id: number, currentUserId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Messages/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (currentUserId === null)
            throw new Error("The parameter 'currentUserId' cannot be null.");
        else if (currentUserId !== undefined)
            url_ += "currentUserId=" + encodeURIComponent("" + currentUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMessagesDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMessagesDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processMessagesDELETE(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currentUserId (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param searchTerm (optional) 
     * @param sortBy (optional) 
     * @param sortDescending (optional) 
     * @return OK
     */
    conversation(conversationId: number, currentUserId: number | undefined, page: number | undefined, pageSize: number | undefined, searchTerm: string | undefined, sortBy: string | undefined, sortDescending: boolean | undefined): Observable<MessageDtoPagedResultDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Messages/conversation/{conversationId}?";
        if (conversationId === undefined || conversationId === null)
            throw new Error("The parameter 'conversationId' must be defined.");
        url_ = url_.replace("{conversationId}", encodeURIComponent("" + conversationId));
        if (currentUserId === null)
            throw new Error("The parameter 'currentUserId' cannot be null.");
        else if (currentUserId !== undefined)
            url_ += "currentUserId=" + encodeURIComponent("" + currentUserId) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDescending === null)
            throw new Error("The parameter 'sortDescending' cannot be null.");
        else if (sortDescending !== undefined)
            url_ += "SortDescending=" + encodeURIComponent("" + sortDescending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConversation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConversation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MessageDtoPagedResultDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MessageDtoPagedResultDtoApiResponseDto>;
        }));
    }

    protected processConversation(response: HttpResponseBase): Observable<MessageDtoPagedResultDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageDtoPagedResultDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param senderId (optional) 
     * @param body (optional) 
     * @return OK
     */
    messagesPOST(senderId: number | undefined, body: CreateMessageDto | undefined): Observable<MessageDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Messages?";
        if (senderId === null)
            throw new Error("The parameter 'senderId' cannot be null.");
        else if (senderId !== undefined)
            url_ += "senderId=" + encodeURIComponent("" + senderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMessagesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMessagesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MessageDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MessageDtoApiResponseDto>;
        }));
    }

    protected processMessagesPOST(response: HttpResponseBase): Observable<MessageDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @return OK
     */
    markRead(conversationId: number, userId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Messages/conversation/{conversationId}/mark-read?";
        if (conversationId === undefined || conversationId === null)
            throw new Error("The parameter 'conversationId' must be defined.");
        url_ = url_.replace("{conversationId}", encodeURIComponent("" + conversationId));
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processMarkRead(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchTermQuery (optional) 
     * @param currentUserId (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param searchTermQuery (optional) 
     * @param sortBy (optional) 
     * @param sortDescending (optional) 
     * @return OK
     */
    search2(conversationId: number, searchTermQuery: string | undefined, currentUserId: number | undefined, page: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortDescending: boolean | undefined): Observable<MessageDtoPagedResultDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Messages/conversation/{conversationId}/search?";
        if (conversationId === undefined || conversationId === null)
            throw new Error("The parameter 'conversationId' must be defined.");
        url_ = url_.replace("{conversationId}", encodeURIComponent("" + conversationId));
        if (searchTermQuery === null)
            throw new Error("The parameter 'searchTermQuery' cannot be null.");
        else if (searchTermQuery !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTermQuery) + "&";
        if (currentUserId === null)
            throw new Error("The parameter 'currentUserId' cannot be null.");
        else if (currentUserId !== undefined)
            url_ += "currentUserId=" + encodeURIComponent("" + currentUserId) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTermQuery === null)
            throw new Error("The parameter 'searchTermQuery' cannot be null.");
        else if (searchTermQuery !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTermQuery) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDescending === null)
            throw new Error("The parameter 'sortDescending' cannot be null.");
        else if (sortDescending !== undefined)
            url_ += "SortDescending=" + encodeURIComponent("" + sortDescending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MessageDtoPagedResultDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MessageDtoPagedResultDtoApiResponseDto>;
        }));
    }

    protected processSearch2(response: HttpResponseBase): Observable<MessageDtoPagedResultDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageDtoPagedResultDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param searchTerm (optional) 
     * @param sortBy (optional) 
     * @param sortDescending (optional) 
     * @return OK
     */
    user3(userId: number, page: number | undefined, pageSize: number | undefined, searchTerm: string | undefined, sortBy: string | undefined, sortDescending: boolean | undefined): Observable<NotificationDtoPagedResultDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Notifications/user/{userId}?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDescending === null)
            throw new Error("The parameter 'sortDescending' cannot be null.");
        else if (sortDescending !== undefined)
            url_ += "SortDescending=" + encodeURIComponent("" + sortDescending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUser3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUser3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationDtoPagedResultDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationDtoPagedResultDtoApiResponseDto>;
        }));
    }

    protected processUser3(response: HttpResponseBase): Observable<NotificationDtoPagedResultDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationDtoPagedResultDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    summary(userId: number): Observable<NotificationSummaryDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Notifications/user/{userId}/summary";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationSummaryDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationSummaryDtoApiResponseDto>;
        }));
    }

    protected processSummary(response: HttpResponseBase): Observable<NotificationSummaryDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationSummaryDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    unreadCount2(userId: number): Observable<Int32ApiResponseDto> {
        let url_ = this.baseUrl + "/api/Notifications/user/{userId}/unread-count";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnreadCount2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnreadCount2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int32ApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int32ApiResponseDto>;
        }));
    }

    protected processUnreadCount2(response: HttpResponseBase): Observable<Int32ApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32ApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    notificationsPOST(body: CreateNotificationDto | undefined): Observable<NotificationDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Notifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotificationsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotificationsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationDtoApiResponseDto>;
        }));
    }

    protected processNotificationsPOST(response: HttpResponseBase): Observable<NotificationDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @return OK
     */
    read2(id: number, userId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Notifications/{id}/read?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRead2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRead2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processRead2(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    markAllRead(userId: number): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Notifications/user/{userId}/mark-all-read";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAllRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processMarkAllRead(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @return OK
     */
    notificationsDELETE(id: number, userId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Notifications/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotificationsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotificationsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processNotificationsDELETE(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param requesterId (optional) 
     * @param addresseeId (optional) 
     * @return OK
     */
    friendRequest(requesterId: number | undefined, addresseeId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Notifications/friend-request?";
        if (requesterId === null)
            throw new Error("The parameter 'requesterId' cannot be null.");
        else if (requesterId !== undefined)
            url_ += "requesterId=" + encodeURIComponent("" + requesterId) + "&";
        if (addresseeId === null)
            throw new Error("The parameter 'addresseeId' cannot be null.");
        else if (addresseeId !== undefined)
            url_ += "addresseeId=" + encodeURIComponent("" + addresseeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFriendRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFriendRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processFriendRequest(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param eventId (optional) 
     * @param invitedUserId (optional) 
     * @param inviterId (optional) 
     * @return OK
     */
    eventInvitation(eventId: number | undefined, invitedUserId: number | undefined, inviterId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Notifications/event-invitation?";
        if (eventId === null)
            throw new Error("The parameter 'eventId' cannot be null.");
        else if (eventId !== undefined)
            url_ += "eventId=" + encodeURIComponent("" + eventId) + "&";
        if (invitedUserId === null)
            throw new Error("The parameter 'invitedUserId' cannot be null.");
        else if (invitedUserId !== undefined)
            url_ += "invitedUserId=" + encodeURIComponent("" + invitedUserId) + "&";
        if (inviterId === null)
            throw new Error("The parameter 'inviterId' cannot be null.");
        else if (inviterId !== undefined)
            url_ += "inviterId=" + encodeURIComponent("" + inviterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEventInvitation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventInvitation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processEventInvitation(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    eventReminders(eventId: number): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Notifications/event-reminders/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEventReminders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventReminders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processEventReminders(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param messageId (optional) 
     * @param recipientId (optional) 
     * @return OK
     */
    newMessage(messageId: number | undefined, recipientId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Notifications/new-message?";
        if (messageId === null)
            throw new Error("The parameter 'messageId' cannot be null.");
        else if (messageId !== undefined)
            url_ += "messageId=" + encodeURIComponent("" + messageId) + "&";
        if (recipientId === null)
            throw new Error("The parameter 'recipientId' cannot be null.");
        else if (recipientId !== undefined)
            url_ += "recipientId=" + encodeURIComponent("" + recipientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewMessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processNewMessage(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    participationsGET(id: number): Observable<ParticipationDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Participations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processParticipationsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processParticipationsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ParticipationDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ParticipationDtoApiResponseDto>;
        }));
    }

    protected processParticipationsGET(response: HttpResponseBase): Observable<ParticipationDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParticipationDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currentUserId (optional) 
     * @param body (optional) 
     * @return OK
     */
    participationsPUT(id: number, currentUserId: number | undefined, body: UpdateParticipationDto | undefined): Observable<ParticipationDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Participations/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (currentUserId === null)
            throw new Error("The parameter 'currentUserId' cannot be null.");
        else if (currentUserId !== undefined)
            url_ += "currentUserId=" + encodeURIComponent("" + currentUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processParticipationsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processParticipationsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ParticipationDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ParticipationDtoApiResponseDto>;
        }));
    }

    protected processParticipationsPUT(response: HttpResponseBase): Observable<ParticipationDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParticipationDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currentUserId (optional) 
     * @return OK
     */
    participationsDELETE(id: number, currentUserId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Participations/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (currentUserId === null)
            throw new Error("The parameter 'currentUserId' cannot be null.");
        else if (currentUserId !== undefined)
            url_ += "currentUserId=" + encodeURIComponent("" + currentUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processParticipationsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processParticipationsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processParticipationsDELETE(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    user4(eventId: number, userId: number): Observable<ParticipationDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Participations/event/{eventId}/user/{userId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUser4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUser4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ParticipationDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ParticipationDtoApiResponseDto>;
        }));
    }

    protected processUser4(response: HttpResponseBase): Observable<ParticipationDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParticipationDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param searchTerm (optional) 
     * @param sortBy (optional) 
     * @param sortDescending (optional) 
     * @return OK
     */
    user5(userId: number, page: number | undefined, pageSize: number | undefined, searchTerm: string | undefined, sortBy: string | undefined, sortDescending: boolean | undefined): Observable<ParticipationDtoPagedResultDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Participations/user/{userId}?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDescending === null)
            throw new Error("The parameter 'sortDescending' cannot be null.");
        else if (sortDescending !== undefined)
            url_ += "SortDescending=" + encodeURIComponent("" + sortDescending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUser5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUser5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ParticipationDtoPagedResultDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ParticipationDtoPagedResultDtoApiResponseDto>;
        }));
    }

    protected processUser5(response: HttpResponseBase): Observable<ParticipationDtoPagedResultDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParticipationDtoPagedResultDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param body (optional) 
     * @return OK
     */
    join(userId: number | undefined, body: CreateParticipationDto | undefined): Observable<ParticipationDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Participations/join?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processJoin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processJoin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ParticipationDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ParticipationDtoApiResponseDto>;
        }));
    }

    protected processJoin(response: HttpResponseBase): Observable<ParticipationDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParticipationDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param eventId (optional) 
     * @param userId (optional) 
     * @return OK
     */
    leave2(eventId: number | undefined, userId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Participations/leave?";
        if (eventId === null)
            throw new Error("The parameter 'eventId' cannot be null.");
        else if (eventId !== undefined)
            url_ += "eventId=" + encodeURIComponent("" + eventId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLeave2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLeave2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processLeave2(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currentUserId (optional) 
     * @return OK
     */
    confirm(id: number, currentUserId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Participations/{id}/confirm?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (currentUserId === null)
            throw new Error("The parameter 'currentUserId' cannot be null.");
        else if (currentUserId !== undefined)
            url_ += "currentUserId=" + encodeURIComponent("" + currentUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processConfirm(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currentUserId (optional) 
     * @return OK
     */
    decline2(id: number, currentUserId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Participations/{id}/decline?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (currentUserId === null)
            throw new Error("The parameter 'currentUserId' cannot be null.");
        else if (currentUserId !== undefined)
            url_ += "currentUserId=" + encodeURIComponent("" + currentUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDecline2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDecline2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processDecline2(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currentUserId (optional) 
     * @return OK
     */
    waitlist(id: number, currentUserId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Participations/{id}/waitlist?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (currentUserId === null)
            throw new Error("The parameter 'currentUserId' cannot be null.");
        else if (currentUserId !== undefined)
            url_ += "currentUserId=" + encodeURIComponent("" + currentUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWaitlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWaitlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processWaitlist(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param eventId (optional) 
     * @param userId (optional) 
     * @return OK
     */
    canJoin(eventId: number | undefined, userId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Participations/can-join?";
        if (eventId === null)
            throw new Error("The parameter 'eventId' cannot be null.");
        else if (eventId !== undefined)
            url_ += "eventId=" + encodeURIComponent("" + eventId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCanJoin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCanJoin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processCanJoin(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param eventId (optional) 
     * @param userId (optional) 
     * @return OK
     */
    isParticipating(eventId: number | undefined, userId: number | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Participations/is-participating?";
        if (eventId === null)
            throw new Error("The parameter 'eventId' cannot be null.");
        else if (eventId !== undefined)
            url_ += "eventId=" + encodeURIComponent("" + eventId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsParticipating(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsParticipating(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processIsParticipating(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    usersGET(id: number): Observable<UserDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponseDto>;
        }));
    }

    protected processUsersGET(response: HttpResponseBase): Observable<UserDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    usersPUT(id: number, body: UpdateUserDto | undefined): Observable<UserDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponseDto>;
        }));
    }

    protected processUsersPUT(response: HttpResponseBase): Observable<UserDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    username(username: string): Observable<UserDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Users/username/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsername(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsername(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponseDto>;
        }));
    }

    protected processUsername(response: HttpResponseBase): Observable<UserDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currentUserId (optional) 
     * @return OK
     */
    profile(id: number, currentUserId: number | undefined): Observable<UserProfileDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Users/{id}/profile?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (currentUserId === null)
            throw new Error("The parameter 'currentUserId' cannot be null.");
        else if (currentUserId !== undefined)
            url_ += "currentUserId=" + encodeURIComponent("" + currentUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileDtoApiResponseDto>;
        }));
    }

    protected processProfile(response: HttpResponseBase): Observable<UserProfileDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfileDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param searchTerm (optional) 
     * @param sortBy (optional) 
     * @param sortDescending (optional) 
     * @return OK
     */
    usersGET2(page: number | undefined, pageSize: number | undefined, searchTerm: string | undefined, sortBy: string | undefined, sortDescending: boolean | undefined): Observable<UserDtoPagedResultDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Users?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDescending === null)
            throw new Error("The parameter 'sortDescending' cannot be null.");
        else if (sortDescending !== undefined)
            url_ += "SortDescending=" + encodeURIComponent("" + sortDescending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersGET2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersGET2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoPagedResultDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoPagedResultDtoApiResponseDto>;
        }));
    }

    protected processUsersGET2(response: HttpResponseBase): Observable<UserDtoPagedResultDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResultDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    usersPOST(body: CreateUserDto | undefined): Observable<UserDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponseDto>;
        }));
    }

    protected processUsersPOST(response: HttpResponseBase): Observable<UserDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchTermQuery (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param searchTermQuery (optional) 
     * @param sortBy (optional) 
     * @param sortDescending (optional) 
     * @return OK
     */
    search3(searchTermQuery: string | undefined, page: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortDescending: boolean | undefined): Observable<UserDtoPagedResultDtoApiResponseDto> {
        let url_ = this.baseUrl + "/api/Users/search?";
        if (searchTermQuery === null)
            throw new Error("The parameter 'searchTermQuery' cannot be null.");
        else if (searchTermQuery !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTermQuery) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTermQuery === null)
            throw new Error("The parameter 'searchTermQuery' cannot be null.");
        else if (searchTermQuery !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTermQuery) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDescending === null)
            throw new Error("The parameter 'sortDescending' cannot be null.");
        else if (sortDescending !== undefined)
            url_ += "SortDescending=" + encodeURIComponent("" + sortDescending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoPagedResultDtoApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoPagedResultDtoApiResponseDto>;
        }));
    }

    protected processSearch3(response: HttpResponseBase): Observable<UserDtoPagedResultDtoApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResultDtoApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    profileImage(id: number, body: string | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Users/{id}/profile-image";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfileImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfileImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processProfileImage(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    changePassword(id: number, body: ChangePasswordDto | undefined): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Users/{id}/change-password";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deactivate2(id: number): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Users/{id}/deactivate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeactivate2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeactivate2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processDeactivate2(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    activate2(id: number): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Users/{id}/activate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processActivate2(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    checkUsername(username: string): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Users/check-username/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckUsername(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckUsername(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processCheckUsername(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    checkEmail(email: string): Observable<BooleanApiResponseDto> {
        let url_ = this.baseUrl + "/api/Users/check-email/{email}";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponseDto>;
        }));
    }

    protected processCheckEmail(response: HttpResponseBase): Observable<BooleanApiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class BooleanApiResponseDto implements IBooleanApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: boolean;
    errors?: string[] | undefined;

    constructor(data?: IBooleanApiResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): BooleanApiResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new BooleanApiResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IBooleanApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: boolean;
    errors?: string[] | undefined;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword?: string | undefined;
    newPassword?: string | undefined;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordDto {
    currentPassword?: string | undefined;
    newPassword?: string | undefined;
}

export class ConversationDto implements IConversationDto {
    conversationId?: number;
    conversationType?: string | undefined;
    title?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    lastActivity?: Date;
    participants?: ConversationParticipantDto[] | undefined;
    messages?: MessageDto[] | undefined;
    unreadMessagesCount?: number;
    lastMessage?: MessageDto;

    constructor(data?: IConversationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conversationId = _data["conversationId"];
            this.conversationType = _data["conversationType"];
            this.title = _data["title"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.lastActivity = _data["lastActivity"] ? new Date(_data["lastActivity"].toString()) : <any>undefined;
            if (Array.isArray(_data["participants"])) {
                this.participants = [] as any;
                for (let item of _data["participants"])
                    this.participants!.push(ConversationParticipantDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(MessageDto.fromJS(item));
            }
            this.unreadMessagesCount = _data["unreadMessagesCount"];
            this.lastMessage = _data["lastMessage"] ? MessageDto.fromJS(_data["lastMessage"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConversationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConversationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["conversationId"] = this.conversationId;
        data["conversationType"] = this.conversationType;
        data["title"] = this.title;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["lastActivity"] = this.lastActivity ? this.lastActivity.toISOString() : <any>undefined;
        if (Array.isArray(this.participants)) {
            data["participants"] = [];
            for (let item of this.participants)
                data["participants"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item ? item.toJSON() : <any>undefined);
        }
        data["unreadMessagesCount"] = this.unreadMessagesCount;
        data["lastMessage"] = this.lastMessage ? this.lastMessage.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConversationDto {
    conversationId?: number;
    conversationType?: string | undefined;
    title?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    lastActivity?: Date;
    participants?: ConversationParticipantDto[] | undefined;
    messages?: MessageDto[] | undefined;
    unreadMessagesCount?: number;
    lastMessage?: MessageDto;
}

export class ConversationDtoApiResponseDto implements IConversationDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: ConversationDto;
    errors?: string[] | undefined;

    constructor(data?: IConversationDtoApiResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"] ? ConversationDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ConversationDtoApiResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConversationDtoApiResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IConversationDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: ConversationDto;
    errors?: string[] | undefined;
}

export class ConversationParticipantDto implements IConversationParticipantDto {
    participantId?: number;
    conversationId?: number;
    userId?: number;
    joinedAt?: Date;
    lastReadAt?: Date | undefined;
    isAdmin?: boolean;
    status?: string | undefined;
    user?: UserDto;

    constructor(data?: IConversationParticipantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.participantId = _data["participantId"];
            this.conversationId = _data["conversationId"];
            this.userId = _data["userId"];
            this.joinedAt = _data["joinedAt"] ? new Date(_data["joinedAt"].toString()) : <any>undefined;
            this.lastReadAt = _data["lastReadAt"] ? new Date(_data["lastReadAt"].toString()) : <any>undefined;
            this.isAdmin = _data["isAdmin"];
            this.status = _data["status"];
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConversationParticipantDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConversationParticipantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["participantId"] = this.participantId;
        data["conversationId"] = this.conversationId;
        data["userId"] = this.userId;
        data["joinedAt"] = this.joinedAt ? this.joinedAt.toISOString() : <any>undefined;
        data["lastReadAt"] = this.lastReadAt ? this.lastReadAt.toISOString() : <any>undefined;
        data["isAdmin"] = this.isAdmin;
        data["status"] = this.status;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConversationParticipantDto {
    participantId?: number;
    conversationId?: number;
    userId?: number;
    joinedAt?: Date;
    lastReadAt?: Date | undefined;
    isAdmin?: boolean;
    status?: string | undefined;
    user?: UserDto;
}

export class ConversationSummaryDto implements IConversationSummaryDto {
    conversationId?: number;
    conversationType?: string | undefined;
    title?: string | undefined;
    displayName?: string | undefined;
    imageUrl?: string | undefined;
    lastActivity?: Date;
    unreadMessagesCount?: number;
    lastMessageContent?: string | undefined;
    lastMessageSender?: string | undefined;
    lastMessageTime?: Date | undefined;

    constructor(data?: IConversationSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conversationId = _data["conversationId"];
            this.conversationType = _data["conversationType"];
            this.title = _data["title"];
            this.displayName = _data["displayName"];
            this.imageUrl = _data["imageUrl"];
            this.lastActivity = _data["lastActivity"] ? new Date(_data["lastActivity"].toString()) : <any>undefined;
            this.unreadMessagesCount = _data["unreadMessagesCount"];
            this.lastMessageContent = _data["lastMessageContent"];
            this.lastMessageSender = _data["lastMessageSender"];
            this.lastMessageTime = _data["lastMessageTime"] ? new Date(_data["lastMessageTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ConversationSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConversationSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["conversationId"] = this.conversationId;
        data["conversationType"] = this.conversationType;
        data["title"] = this.title;
        data["displayName"] = this.displayName;
        data["imageUrl"] = this.imageUrl;
        data["lastActivity"] = this.lastActivity ? this.lastActivity.toISOString() : <any>undefined;
        data["unreadMessagesCount"] = this.unreadMessagesCount;
        data["lastMessageContent"] = this.lastMessageContent;
        data["lastMessageSender"] = this.lastMessageSender;
        data["lastMessageTime"] = this.lastMessageTime ? this.lastMessageTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IConversationSummaryDto {
    conversationId?: number;
    conversationType?: string | undefined;
    title?: string | undefined;
    displayName?: string | undefined;
    imageUrl?: string | undefined;
    lastActivity?: Date;
    unreadMessagesCount?: number;
    lastMessageContent?: string | undefined;
    lastMessageSender?: string | undefined;
    lastMessageTime?: Date | undefined;
}

export class ConversationSummaryDtoPagedResultDto implements IConversationSummaryDtoPagedResultDto {
    items?: ConversationSummaryDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    readonly totalPages?: number;
    readonly hasNextPage?: boolean;
    readonly hasPreviousPage?: boolean;

    constructor(data?: IConversationSummaryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ConversationSummaryDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            (<any>this).totalPages = _data["totalPages"];
            (<any>this).hasNextPage = _data["hasNextPage"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
        }
    }

    static fromJS(data: any): ConversationSummaryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConversationSummaryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasNextPage"] = this.hasNextPage;
        data["hasPreviousPage"] = this.hasPreviousPage;
        return data;
    }
}

export interface IConversationSummaryDtoPagedResultDto {
    items?: ConversationSummaryDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;
    hasPreviousPage?: boolean;
}

export class ConversationSummaryDtoPagedResultDtoApiResponseDto implements IConversationSummaryDtoPagedResultDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: ConversationSummaryDtoPagedResultDto;
    errors?: string[] | undefined;

    constructor(data?: IConversationSummaryDtoPagedResultDtoApiResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"] ? ConversationSummaryDtoPagedResultDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ConversationSummaryDtoPagedResultDtoApiResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConversationSummaryDtoPagedResultDtoApiResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IConversationSummaryDtoPagedResultDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: ConversationSummaryDtoPagedResultDto;
    errors?: string[] | undefined;
}

export class CreateConversationDto implements ICreateConversationDto {
    conversationType!: string;
    title?: string | undefined;
    participantIds!: number[];

    constructor(data?: ICreateConversationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.participantIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conversationType = _data["conversationType"];
            this.title = _data["title"];
            if (Array.isArray(_data["participantIds"])) {
                this.participantIds = [] as any;
                for (let item of _data["participantIds"])
                    this.participantIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateConversationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateConversationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["conversationType"] = this.conversationType;
        data["title"] = this.title;
        if (Array.isArray(this.participantIds)) {
            data["participantIds"] = [];
            for (let item of this.participantIds)
                data["participantIds"].push(item);
        }
        return data;
    }
}

export interface ICreateConversationDto {
    conversationType: string;
    title?: string | undefined;
    participantIds: number[];
}

export class CreateEventDto implements ICreateEventDto {
    title!: string;
    description?: string | undefined;
    eventDate!: Date;
    registrationDeadline?: Date | undefined;
    locationName!: string;
    latitude?: number | undefined;
    longitude?: number | undefined;
    maxParticipants?: number | undefined;
    cost?: number | undefined;
    currency?: string | undefined;
    typeId!: number;
    additionalInfo?: string | undefined;

    constructor(data?: ICreateEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.description = _data["description"];
            this.eventDate = _data["eventDate"] ? new Date(_data["eventDate"].toString()) : <any>undefined;
            this.registrationDeadline = _data["registrationDeadline"] ? new Date(_data["registrationDeadline"].toString()) : <any>undefined;
            this.locationName = _data["locationName"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.maxParticipants = _data["maxParticipants"];
            this.cost = _data["cost"];
            this.currency = _data["currency"];
            this.typeId = _data["typeId"];
            this.additionalInfo = _data["additionalInfo"];
        }
    }

    static fromJS(data: any): CreateEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["description"] = this.description;
        data["eventDate"] = this.eventDate ? this.eventDate.toISOString() : <any>undefined;
        data["registrationDeadline"] = this.registrationDeadline ? this.registrationDeadline.toISOString() : <any>undefined;
        data["locationName"] = this.locationName;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["maxParticipants"] = this.maxParticipants;
        data["cost"] = this.cost;
        data["currency"] = this.currency;
        data["typeId"] = this.typeId;
        data["additionalInfo"] = this.additionalInfo;
        return data;
    }
}

export interface ICreateEventDto {
    title: string;
    description?: string | undefined;
    eventDate: Date;
    registrationDeadline?: Date | undefined;
    locationName: string;
    latitude?: number | undefined;
    longitude?: number | undefined;
    maxParticipants?: number | undefined;
    cost?: number | undefined;
    currency?: string | undefined;
    typeId: number;
    additionalInfo?: string | undefined;
}

export class CreateEventTypeDto implements ICreateEventTypeDto {
    typeName!: string;
    description?: string | undefined;
    iconName?: string | undefined;

    constructor(data?: ICreateEventTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeName = _data["typeName"];
            this.description = _data["description"];
            this.iconName = _data["iconName"];
        }
    }

    static fromJS(data: any): CreateEventTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEventTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeName"] = this.typeName;
        data["description"] = this.description;
        data["iconName"] = this.iconName;
        return data;
    }
}

export interface ICreateEventTypeDto {
    typeName: string;
    description?: string | undefined;
    iconName?: string | undefined;
}

export class CreateFriendshipRequestDto implements ICreateFriendshipRequestDto {
    addresseeId!: number;

    constructor(data?: ICreateFriendshipRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addresseeId = _data["addresseeId"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addresseeId"] = this.addresseeId;
        return data;
    }
}

export interface ICreateFriendshipRequestDto {
    addresseeId: number;
}

export class CreateMessageDto implements ICreateMessageDto {
    conversationId!: number;
    content!: string;
    messageType?: string | undefined;
    attachmentUrl?: string | undefined;
    replyToMessageId?: number | undefined;

    constructor(data?: ICreateMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conversationId = _data["conversationId"];
            this.content = _data["content"];
            this.messageType = _data["messageType"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.replyToMessageId = _data["replyToMessageId"];
        }
    }

    static fromJS(data: any): CreateMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["conversationId"] = this.conversationId;
        data["content"] = this.content;
        data["messageType"] = this.messageType;
        data["attachmentUrl"] = this.attachmentUrl;
        data["replyToMessageId"] = this.replyToMessageId;
        return data;
    }
}

export interface ICreateMessageDto {
    conversationId: number;
    content: string;
    messageType?: string | undefined;
    attachmentUrl?: string | undefined;
    replyToMessageId?: number | undefined;
}

export class CreateNotificationDto implements ICreateNotificationDto {
    userId!: number;
    notificationType!: string;
    title!: string;
    content?: string | undefined;
    referenceType?: string | undefined;
    referenceId?: number | undefined;

    constructor(data?: ICreateNotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.notificationType = _data["notificationType"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.referenceType = _data["referenceType"];
            this.referenceId = _data["referenceId"];
        }
    }

    static fromJS(data: any): CreateNotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["notificationType"] = this.notificationType;
        data["title"] = this.title;
        data["content"] = this.content;
        data["referenceType"] = this.referenceType;
        data["referenceId"] = this.referenceId;
        return data;
    }
}

export interface ICreateNotificationDto {
    userId: number;
    notificationType: string;
    title: string;
    content?: string | undefined;
    referenceType?: string | undefined;
    referenceId?: number | undefined;
}

export class CreateParticipationDto implements ICreateParticipationDto {
    eventId!: number;
    notes?: string | undefined;

    constructor(data?: ICreateParticipationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventId = _data["eventId"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): CreateParticipationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateParticipationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventId"] = this.eventId;
        data["notes"] = this.notes;
        return data;
    }
}

export interface ICreateParticipationDto {
    eventId: number;
    notes?: string | undefined;
}

export class CreateUserDto implements ICreateUserDto {
    username!: string;
    email!: string;
    password!: string;
    firstName!: string;
    lastName!: string;
    bio?: string | undefined;
    phoneNumber?: string | undefined;
    dateOfBirth?: Date | undefined;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.bio = _data["bio"];
            this.phoneNumber = _data["phoneNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["email"] = this.email;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["bio"] = this.bio;
        data["phoneNumber"] = this.phoneNumber;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICreateUserDto {
    username: string;
    email: string;
    password: string;
    firstName: string;
    lastName: string;
    bio?: string | undefined;
    phoneNumber?: string | undefined;
    dateOfBirth?: Date | undefined;
}

export class EventDto implements IEventDto {
    eventId?: number;
    title?: string | undefined;
    description?: string | undefined;
    eventDate?: Date;
    registrationDeadline?: Date | undefined;
    locationName?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;
    maxParticipants?: number | undefined;
    cost?: number | undefined;
    currency?: string | undefined;
    status?: string | undefined;
    additionalInfo?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    creator?: UserDto;
    eventType?: EventTypeDto;
    participations?: ParticipationDto[] | undefined;
    images?: EventImageDto[] | undefined;
    currentParticipants?: number;
    isUserParticipating?: boolean;
    canUserJoin?: boolean;

    constructor(data?: IEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventId = _data["eventId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.eventDate = _data["eventDate"] ? new Date(_data["eventDate"].toString()) : <any>undefined;
            this.registrationDeadline = _data["registrationDeadline"] ? new Date(_data["registrationDeadline"].toString()) : <any>undefined;
            this.locationName = _data["locationName"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.maxParticipants = _data["maxParticipants"];
            this.cost = _data["cost"];
            this.currency = _data["currency"];
            this.status = _data["status"];
            this.additionalInfo = _data["additionalInfo"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.creator = _data["creator"] ? UserDto.fromJS(_data["creator"]) : <any>undefined;
            this.eventType = _data["eventType"] ? EventTypeDto.fromJS(_data["eventType"]) : <any>undefined;
            if (Array.isArray(_data["participations"])) {
                this.participations = [] as any;
                for (let item of _data["participations"])
                    this.participations!.push(ParticipationDto.fromJS(item));
            }
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(EventImageDto.fromJS(item));
            }
            this.currentParticipants = _data["currentParticipants"];
            this.isUserParticipating = _data["isUserParticipating"];
            this.canUserJoin = _data["canUserJoin"];
        }
    }

    static fromJS(data: any): EventDto {
        data = typeof data === 'object' ? data : {};
        let result = new EventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventId"] = this.eventId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["eventDate"] = this.eventDate ? this.eventDate.toISOString() : <any>undefined;
        data["registrationDeadline"] = this.registrationDeadline ? this.registrationDeadline.toISOString() : <any>undefined;
        data["locationName"] = this.locationName;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["maxParticipants"] = this.maxParticipants;
        data["cost"] = this.cost;
        data["currency"] = this.currency;
        data["status"] = this.status;
        data["additionalInfo"] = this.additionalInfo;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["eventType"] = this.eventType ? this.eventType.toJSON() : <any>undefined;
        if (Array.isArray(this.participations)) {
            data["participations"] = [];
            for (let item of this.participations)
                data["participations"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item ? item.toJSON() : <any>undefined);
        }
        data["currentParticipants"] = this.currentParticipants;
        data["isUserParticipating"] = this.isUserParticipating;
        data["canUserJoin"] = this.canUserJoin;
        return data;
    }
}

export interface IEventDto {
    eventId?: number;
    title?: string | undefined;
    description?: string | undefined;
    eventDate?: Date;
    registrationDeadline?: Date | undefined;
    locationName?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;
    maxParticipants?: number | undefined;
    cost?: number | undefined;
    currency?: string | undefined;
    status?: string | undefined;
    additionalInfo?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    creator?: UserDto;
    eventType?: EventTypeDto;
    participations?: ParticipationDto[] | undefined;
    images?: EventImageDto[] | undefined;
    currentParticipants?: number;
    isUserParticipating?: boolean;
    canUserJoin?: boolean;
}

export class EventDtoApiResponseDto implements IEventDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: EventDto;
    errors?: string[] | undefined;

    constructor(data?: IEventDtoApiResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"] ? EventDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): EventDtoApiResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new EventDtoApiResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IEventDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: EventDto;
    errors?: string[] | undefined;
}

export class EventImageDto implements IEventImageDto {
    imageId?: number;
    eventId?: number;
    imageUrl?: string | undefined;
    caption?: string | undefined;
    isPrimary?: boolean;
    sortOrder?: number;
    uploadedAt?: Date;

    constructor(data?: IEventImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.imageId = _data["imageId"];
            this.eventId = _data["eventId"];
            this.imageUrl = _data["imageUrl"];
            this.caption = _data["caption"];
            this.isPrimary = _data["isPrimary"];
            this.sortOrder = _data["sortOrder"];
            this.uploadedAt = _data["uploadedAt"] ? new Date(_data["uploadedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EventImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new EventImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imageId"] = this.imageId;
        data["eventId"] = this.eventId;
        data["imageUrl"] = this.imageUrl;
        data["caption"] = this.caption;
        data["isPrimary"] = this.isPrimary;
        data["sortOrder"] = this.sortOrder;
        data["uploadedAt"] = this.uploadedAt ? this.uploadedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IEventImageDto {
    imageId?: number;
    eventId?: number;
    imageUrl?: string | undefined;
    caption?: string | undefined;
    isPrimary?: boolean;
    sortOrder?: number;
    uploadedAt?: Date;
}

export class EventSummaryDto implements IEventSummaryDto {
    eventId?: number;
    title?: string | undefined;
    eventDate?: Date;
    locationName?: string | undefined;
    cost?: number | undefined;
    currency?: string | undefined;
    status?: string | undefined;
    creatorName?: string | undefined;
    eventTypeName?: string | undefined;
    currentParticipants?: number;
    maxParticipants?: number | undefined;
    primaryImageUrl?: string | undefined;

    constructor(data?: IEventSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventId = _data["eventId"];
            this.title = _data["title"];
            this.eventDate = _data["eventDate"] ? new Date(_data["eventDate"].toString()) : <any>undefined;
            this.locationName = _data["locationName"];
            this.cost = _data["cost"];
            this.currency = _data["currency"];
            this.status = _data["status"];
            this.creatorName = _data["creatorName"];
            this.eventTypeName = _data["eventTypeName"];
            this.currentParticipants = _data["currentParticipants"];
            this.maxParticipants = _data["maxParticipants"];
            this.primaryImageUrl = _data["primaryImageUrl"];
        }
    }

    static fromJS(data: any): EventSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new EventSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventId"] = this.eventId;
        data["title"] = this.title;
        data["eventDate"] = this.eventDate ? this.eventDate.toISOString() : <any>undefined;
        data["locationName"] = this.locationName;
        data["cost"] = this.cost;
        data["currency"] = this.currency;
        data["status"] = this.status;
        data["creatorName"] = this.creatorName;
        data["eventTypeName"] = this.eventTypeName;
        data["currentParticipants"] = this.currentParticipants;
        data["maxParticipants"] = this.maxParticipants;
        data["primaryImageUrl"] = this.primaryImageUrl;
        return data;
    }
}

export interface IEventSummaryDto {
    eventId?: number;
    title?: string | undefined;
    eventDate?: Date;
    locationName?: string | undefined;
    cost?: number | undefined;
    currency?: string | undefined;
    status?: string | undefined;
    creatorName?: string | undefined;
    eventTypeName?: string | undefined;
    currentParticipants?: number;
    maxParticipants?: number | undefined;
    primaryImageUrl?: string | undefined;
}

export class EventSummaryDtoPagedResultDto implements IEventSummaryDtoPagedResultDto {
    items?: EventSummaryDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    readonly totalPages?: number;
    readonly hasNextPage?: boolean;
    readonly hasPreviousPage?: boolean;

    constructor(data?: IEventSummaryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EventSummaryDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            (<any>this).totalPages = _data["totalPages"];
            (<any>this).hasNextPage = _data["hasNextPage"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
        }
    }

    static fromJS(data: any): EventSummaryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new EventSummaryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasNextPage"] = this.hasNextPage;
        data["hasPreviousPage"] = this.hasPreviousPage;
        return data;
    }
}

export interface IEventSummaryDtoPagedResultDto {
    items?: EventSummaryDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;
    hasPreviousPage?: boolean;
}

export class EventSummaryDtoPagedResultDtoApiResponseDto implements IEventSummaryDtoPagedResultDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: EventSummaryDtoPagedResultDto;
    errors?: string[] | undefined;

    constructor(data?: IEventSummaryDtoPagedResultDtoApiResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"] ? EventSummaryDtoPagedResultDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): EventSummaryDtoPagedResultDtoApiResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new EventSummaryDtoPagedResultDtoApiResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IEventSummaryDtoPagedResultDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: EventSummaryDtoPagedResultDto;
    errors?: string[] | undefined;
}

export class EventTypeDto implements IEventTypeDto {
    typeId?: number;
    typeName?: string | undefined;
    description?: string | undefined;
    iconName?: string | undefined;
    isActive?: boolean;
    createdAt?: Date;

    constructor(data?: IEventTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeId = _data["typeId"];
            this.typeName = _data["typeName"];
            this.description = _data["description"];
            this.iconName = _data["iconName"];
            this.isActive = _data["isActive"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EventTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EventTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["typeName"] = this.typeName;
        data["description"] = this.description;
        data["iconName"] = this.iconName;
        data["isActive"] = this.isActive;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IEventTypeDto {
    typeId?: number;
    typeName?: string | undefined;
    description?: string | undefined;
    iconName?: string | undefined;
    isActive?: boolean;
    createdAt?: Date;
}

export class EventTypeDtoApiResponseDto implements IEventTypeDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: EventTypeDto;
    errors?: string[] | undefined;

    constructor(data?: IEventTypeDtoApiResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"] ? EventTypeDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): EventTypeDtoApiResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new EventTypeDtoApiResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IEventTypeDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: EventTypeDto;
    errors?: string[] | undefined;
}

export class EventTypeDtoPagedResultDto implements IEventTypeDtoPagedResultDto {
    items?: EventTypeDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    readonly totalPages?: number;
    readonly hasNextPage?: boolean;
    readonly hasPreviousPage?: boolean;

    constructor(data?: IEventTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EventTypeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            (<any>this).totalPages = _data["totalPages"];
            (<any>this).hasNextPage = _data["hasNextPage"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
        }
    }

    static fromJS(data: any): EventTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new EventTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasNextPage"] = this.hasNextPage;
        data["hasPreviousPage"] = this.hasPreviousPage;
        return data;
    }
}

export interface IEventTypeDtoPagedResultDto {
    items?: EventTypeDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;
    hasPreviousPage?: boolean;
}

export class EventTypeDtoPagedResultDtoApiResponseDto implements IEventTypeDtoPagedResultDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: EventTypeDtoPagedResultDto;
    errors?: string[] | undefined;

    constructor(data?: IEventTypeDtoPagedResultDtoApiResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"] ? EventTypeDtoPagedResultDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): EventTypeDtoPagedResultDtoApiResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new EventTypeDtoPagedResultDtoApiResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IEventTypeDtoPagedResultDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: EventTypeDtoPagedResultDto;
    errors?: string[] | undefined;
}

export class FriendDto implements IFriendDto {
    userId?: number;
    username?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    profileImageUrl?: string | undefined;
    isOnline?: boolean;
    friendsSince?: Date;

    constructor(data?: IFriendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.username = _data["username"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.profileImageUrl = _data["profileImageUrl"];
            this.isOnline = _data["isOnline"];
            this.friendsSince = _data["friendsSince"] ? new Date(_data["friendsSince"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FriendDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["username"] = this.username;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["profileImageUrl"] = this.profileImageUrl;
        data["isOnline"] = this.isOnline;
        data["friendsSince"] = this.friendsSince ? this.friendsSince.toISOString() : <any>undefined;
        return data;
    }
}

export interface IFriendDto {
    userId?: number;
    username?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    profileImageUrl?: string | undefined;
    isOnline?: boolean;
    friendsSince?: Date;
}

export class FriendDtoPagedResultDto implements IFriendDtoPagedResultDto {
    items?: FriendDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    readonly totalPages?: number;
    readonly hasNextPage?: boolean;
    readonly hasPreviousPage?: boolean;

    constructor(data?: IFriendDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FriendDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            (<any>this).totalPages = _data["totalPages"];
            (<any>this).hasNextPage = _data["hasNextPage"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
        }
    }

    static fromJS(data: any): FriendDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasNextPage"] = this.hasNextPage;
        data["hasPreviousPage"] = this.hasPreviousPage;
        return data;
    }
}

export interface IFriendDtoPagedResultDto {
    items?: FriendDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;
    hasPreviousPage?: boolean;
}

export class FriendDtoPagedResultDtoApiResponseDto implements IFriendDtoPagedResultDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: FriendDtoPagedResultDto;
    errors?: string[] | undefined;

    constructor(data?: IFriendDtoPagedResultDtoApiResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"] ? FriendDtoPagedResultDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): FriendDtoPagedResultDtoApiResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendDtoPagedResultDtoApiResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IFriendDtoPagedResultDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: FriendDtoPagedResultDto;
    errors?: string[] | undefined;
}

export class FriendRequestDto implements IFriendRequestDto {
    friendshipId?: number;
    requesterId?: number;
    requesterUsername?: string | undefined;
    requesterFirstName?: string | undefined;
    requesterLastName?: string | undefined;
    requesterProfileImage?: string | undefined;
    requestDate?: Date;
    status?: string | undefined;

    constructor(data?: IFriendRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.friendshipId = _data["friendshipId"];
            this.requesterId = _data["requesterId"];
            this.requesterUsername = _data["requesterUsername"];
            this.requesterFirstName = _data["requesterFirstName"];
            this.requesterLastName = _data["requesterLastName"];
            this.requesterProfileImage = _data["requesterProfileImage"];
            this.requestDate = _data["requestDate"] ? new Date(_data["requestDate"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): FriendRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendshipId"] = this.friendshipId;
        data["requesterId"] = this.requesterId;
        data["requesterUsername"] = this.requesterUsername;
        data["requesterFirstName"] = this.requesterFirstName;
        data["requesterLastName"] = this.requesterLastName;
        data["requesterProfileImage"] = this.requesterProfileImage;
        data["requestDate"] = this.requestDate ? this.requestDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data;
    }
}

export interface IFriendRequestDto {
    friendshipId?: number;
    requesterId?: number;
    requesterUsername?: string | undefined;
    requesterFirstName?: string | undefined;
    requesterLastName?: string | undefined;
    requesterProfileImage?: string | undefined;
    requestDate?: Date;
    status?: string | undefined;
}

export class FriendRequestDtoPagedResultDto implements IFriendRequestDtoPagedResultDto {
    items?: FriendRequestDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    readonly totalPages?: number;
    readonly hasNextPage?: boolean;
    readonly hasPreviousPage?: boolean;

    constructor(data?: IFriendRequestDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FriendRequestDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            (<any>this).totalPages = _data["totalPages"];
            (<any>this).hasNextPage = _data["hasNextPage"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
        }
    }

    static fromJS(data: any): FriendRequestDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendRequestDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasNextPage"] = this.hasNextPage;
        data["hasPreviousPage"] = this.hasPreviousPage;
        return data;
    }
}

export interface IFriendRequestDtoPagedResultDto {
    items?: FriendRequestDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;
    hasPreviousPage?: boolean;
}

export class FriendRequestDtoPagedResultDtoApiResponseDto implements IFriendRequestDtoPagedResultDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: FriendRequestDtoPagedResultDto;
    errors?: string[] | undefined;

    constructor(data?: IFriendRequestDtoPagedResultDtoApiResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"] ? FriendRequestDtoPagedResultDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): FriendRequestDtoPagedResultDtoApiResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendRequestDtoPagedResultDtoApiResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IFriendRequestDtoPagedResultDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: FriendRequestDtoPagedResultDto;
    errors?: string[] | undefined;
}

export class FriendshipDto implements IFriendshipDto {
    friendshipId?: number;
    requesterId?: number;
    addresseeId?: number;
    status?: string | undefined;
    requestDate?: Date;
    responseDate?: Date | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    requester?: UserDto;
    addressee?: UserDto;

    constructor(data?: IFriendshipDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.friendshipId = _data["friendshipId"];
            this.requesterId = _data["requesterId"];
            this.addresseeId = _data["addresseeId"];
            this.status = _data["status"];
            this.requestDate = _data["requestDate"] ? new Date(_data["requestDate"].toString()) : <any>undefined;
            this.responseDate = _data["responseDate"] ? new Date(_data["responseDate"].toString()) : <any>undefined;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.requester = _data["requester"] ? UserDto.fromJS(_data["requester"]) : <any>undefined;
            this.addressee = _data["addressee"] ? UserDto.fromJS(_data["addressee"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FriendshipDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendshipDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendshipId"] = this.friendshipId;
        data["requesterId"] = this.requesterId;
        data["addresseeId"] = this.addresseeId;
        data["status"] = this.status;
        data["requestDate"] = this.requestDate ? this.requestDate.toISOString() : <any>undefined;
        data["responseDate"] = this.responseDate ? this.responseDate.toISOString() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["requester"] = this.requester ? this.requester.toJSON() : <any>undefined;
        data["addressee"] = this.addressee ? this.addressee.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFriendshipDto {
    friendshipId?: number;
    requesterId?: number;
    addresseeId?: number;
    status?: string | undefined;
    requestDate?: Date;
    responseDate?: Date | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    requester?: UserDto;
    addressee?: UserDto;
}

export class FriendshipDtoApiResponseDto implements IFriendshipDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: FriendshipDto;
    errors?: string[] | undefined;

    constructor(data?: IFriendshipDtoApiResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"] ? FriendshipDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): FriendshipDtoApiResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendshipDtoApiResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IFriendshipDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: FriendshipDto;
    errors?: string[] | undefined;
}

export class Int32ApiResponseDto implements IInt32ApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: number;
    errors?: string[] | undefined;

    constructor(data?: IInt32ApiResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): Int32ApiResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int32ApiResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IInt32ApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: number;
    errors?: string[] | undefined;
}

export class MessageDto implements IMessageDto {
    messageId?: number;
    conversationId?: number;
    senderId?: number;
    content?: string | undefined;
    messageType?: string | undefined;
    attachmentUrl?: string | undefined;
    sentAt?: Date;
    editedAt?: Date | undefined;
    isDeleted?: boolean;
    replyToMessageId?: number | undefined;
    sender?: UserDto;
    replyToMessage?: MessageDto;
    isRead?: boolean;

    constructor(data?: IMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.messageId = _data["messageId"];
            this.conversationId = _data["conversationId"];
            this.senderId = _data["senderId"];
            this.content = _data["content"];
            this.messageType = _data["messageType"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.sentAt = _data["sentAt"] ? new Date(_data["sentAt"].toString()) : <any>undefined;
            this.editedAt = _data["editedAt"] ? new Date(_data["editedAt"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.replyToMessageId = _data["replyToMessageId"];
            this.sender = _data["sender"] ? UserDto.fromJS(_data["sender"]) : <any>undefined;
            this.replyToMessage = _data["replyToMessage"] ? MessageDto.fromJS(_data["replyToMessage"]) : <any>undefined;
            this.isRead = _data["isRead"];
        }
    }

    static fromJS(data: any): MessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["messageId"] = this.messageId;
        data["conversationId"] = this.conversationId;
        data["senderId"] = this.senderId;
        data["content"] = this.content;
        data["messageType"] = this.messageType;
        data["attachmentUrl"] = this.attachmentUrl;
        data["sentAt"] = this.sentAt ? this.sentAt.toISOString() : <any>undefined;
        data["editedAt"] = this.editedAt ? this.editedAt.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["replyToMessageId"] = this.replyToMessageId;
        data["sender"] = this.sender ? this.sender.toJSON() : <any>undefined;
        data["replyToMessage"] = this.replyToMessage ? this.replyToMessage.toJSON() : <any>undefined;
        data["isRead"] = this.isRead;
        return data;
    }
}

export interface IMessageDto {
    messageId?: number;
    conversationId?: number;
    senderId?: number;
    content?: string | undefined;
    messageType?: string | undefined;
    attachmentUrl?: string | undefined;
    sentAt?: Date;
    editedAt?: Date | undefined;
    isDeleted?: boolean;
    replyToMessageId?: number | undefined;
    sender?: UserDto;
    replyToMessage?: MessageDto;
    isRead?: boolean;
}

export class MessageDtoApiResponseDto implements IMessageDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: MessageDto;
    errors?: string[] | undefined;

    constructor(data?: IMessageDtoApiResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"] ? MessageDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): MessageDtoApiResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageDtoApiResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IMessageDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: MessageDto;
    errors?: string[] | undefined;
}

export class MessageDtoPagedResultDto implements IMessageDtoPagedResultDto {
    items?: MessageDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    readonly totalPages?: number;
    readonly hasNextPage?: boolean;
    readonly hasPreviousPage?: boolean;

    constructor(data?: IMessageDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MessageDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            (<any>this).totalPages = _data["totalPages"];
            (<any>this).hasNextPage = _data["hasNextPage"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
        }
    }

    static fromJS(data: any): MessageDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasNextPage"] = this.hasNextPage;
        data["hasPreviousPage"] = this.hasPreviousPage;
        return data;
    }
}

export interface IMessageDtoPagedResultDto {
    items?: MessageDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;
    hasPreviousPage?: boolean;
}

export class MessageDtoPagedResultDtoApiResponseDto implements IMessageDtoPagedResultDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: MessageDtoPagedResultDto;
    errors?: string[] | undefined;

    constructor(data?: IMessageDtoPagedResultDtoApiResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"] ? MessageDtoPagedResultDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): MessageDtoPagedResultDtoApiResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageDtoPagedResultDtoApiResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IMessageDtoPagedResultDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: MessageDtoPagedResultDto;
    errors?: string[] | undefined;
}

export class NotificationDto implements INotificationDto {
    notificationId?: number;
    userId?: number;
    notificationType?: string | undefined;
    title?: string | undefined;
    content?: string | undefined;
    referenceType?: string | undefined;
    referenceId?: number | undefined;
    isRead?: boolean;
    createdAt?: Date;
    readAt?: Date | undefined;
    actionUrl?: string | undefined;
    iconName?: string | undefined;

    constructor(data?: INotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notificationId = _data["notificationId"];
            this.userId = _data["userId"];
            this.notificationType = _data["notificationType"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.referenceType = _data["referenceType"];
            this.referenceId = _data["referenceId"];
            this.isRead = _data["isRead"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.readAt = _data["readAt"] ? new Date(_data["readAt"].toString()) : <any>undefined;
            this.actionUrl = _data["actionUrl"];
            this.iconName = _data["iconName"];
        }
    }

    static fromJS(data: any): NotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationId"] = this.notificationId;
        data["userId"] = this.userId;
        data["notificationType"] = this.notificationType;
        data["title"] = this.title;
        data["content"] = this.content;
        data["referenceType"] = this.referenceType;
        data["referenceId"] = this.referenceId;
        data["isRead"] = this.isRead;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["readAt"] = this.readAt ? this.readAt.toISOString() : <any>undefined;
        data["actionUrl"] = this.actionUrl;
        data["iconName"] = this.iconName;
        return data;
    }
}

export interface INotificationDto {
    notificationId?: number;
    userId?: number;
    notificationType?: string | undefined;
    title?: string | undefined;
    content?: string | undefined;
    referenceType?: string | undefined;
    referenceId?: number | undefined;
    isRead?: boolean;
    createdAt?: Date;
    readAt?: Date | undefined;
    actionUrl?: string | undefined;
    iconName?: string | undefined;
}

export class NotificationDtoApiResponseDto implements INotificationDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: NotificationDto;
    errors?: string[] | undefined;

    constructor(data?: INotificationDtoApiResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"] ? NotificationDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): NotificationDtoApiResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDtoApiResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface INotificationDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: NotificationDto;
    errors?: string[] | undefined;
}

export class NotificationDtoPagedResultDto implements INotificationDtoPagedResultDto {
    items?: NotificationDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    readonly totalPages?: number;
    readonly hasNextPage?: boolean;
    readonly hasPreviousPage?: boolean;

    constructor(data?: INotificationDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NotificationDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            (<any>this).totalPages = _data["totalPages"];
            (<any>this).hasNextPage = _data["hasNextPage"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
        }
    }

    static fromJS(data: any): NotificationDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasNextPage"] = this.hasNextPage;
        data["hasPreviousPage"] = this.hasPreviousPage;
        return data;
    }
}

export interface INotificationDtoPagedResultDto {
    items?: NotificationDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;
    hasPreviousPage?: boolean;
}

export class NotificationDtoPagedResultDtoApiResponseDto implements INotificationDtoPagedResultDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: NotificationDtoPagedResultDto;
    errors?: string[] | undefined;

    constructor(data?: INotificationDtoPagedResultDtoApiResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"] ? NotificationDtoPagedResultDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): NotificationDtoPagedResultDtoApiResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDtoPagedResultDtoApiResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface INotificationDtoPagedResultDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: NotificationDtoPagedResultDto;
    errors?: string[] | undefined;
}

export class NotificationSummaryDto implements INotificationSummaryDto {
    unreadCount?: number;
    lastNotificationTime?: Date | undefined;
    hasUnreadFriendRequests?: boolean;
    hasUnreadMessages?: boolean;
    hasUnreadEventUpdates?: boolean;

    constructor(data?: INotificationSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unreadCount = _data["unreadCount"];
            this.lastNotificationTime = _data["lastNotificationTime"] ? new Date(_data["lastNotificationTime"].toString()) : <any>undefined;
            this.hasUnreadFriendRequests = _data["hasUnreadFriendRequests"];
            this.hasUnreadMessages = _data["hasUnreadMessages"];
            this.hasUnreadEventUpdates = _data["hasUnreadEventUpdates"];
        }
    }

    static fromJS(data: any): NotificationSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unreadCount"] = this.unreadCount;
        data["lastNotificationTime"] = this.lastNotificationTime ? this.lastNotificationTime.toISOString() : <any>undefined;
        data["hasUnreadFriendRequests"] = this.hasUnreadFriendRequests;
        data["hasUnreadMessages"] = this.hasUnreadMessages;
        data["hasUnreadEventUpdates"] = this.hasUnreadEventUpdates;
        return data;
    }
}

export interface INotificationSummaryDto {
    unreadCount?: number;
    lastNotificationTime?: Date | undefined;
    hasUnreadFriendRequests?: boolean;
    hasUnreadMessages?: boolean;
    hasUnreadEventUpdates?: boolean;
}

export class NotificationSummaryDtoApiResponseDto implements INotificationSummaryDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: NotificationSummaryDto;
    errors?: string[] | undefined;

    constructor(data?: INotificationSummaryDtoApiResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"] ? NotificationSummaryDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): NotificationSummaryDtoApiResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSummaryDtoApiResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface INotificationSummaryDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: NotificationSummaryDto;
    errors?: string[] | undefined;
}

export class ParticipationDto implements IParticipationDto {
    participationId?: number;
    eventId?: number;
    userId?: number;
    status?: string | undefined;
    participationDate?: Date;
    notes?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    user?: UserDto;
    event?: EventSummaryDto;

    constructor(data?: IParticipationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.participationId = _data["participationId"];
            this.eventId = _data["eventId"];
            this.userId = _data["userId"];
            this.status = _data["status"];
            this.participationDate = _data["participationDate"] ? new Date(_data["participationDate"].toString()) : <any>undefined;
            this.notes = _data["notes"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
            this.event = _data["event"] ? EventSummaryDto.fromJS(_data["event"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ParticipationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["participationId"] = this.participationId;
        data["eventId"] = this.eventId;
        data["userId"] = this.userId;
        data["status"] = this.status;
        data["participationDate"] = this.participationDate ? this.participationDate.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["event"] = this.event ? this.event.toJSON() : <any>undefined;
        return data;
    }
}

export interface IParticipationDto {
    participationId?: number;
    eventId?: number;
    userId?: number;
    status?: string | undefined;
    participationDate?: Date;
    notes?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    user?: UserDto;
    event?: EventSummaryDto;
}

export class ParticipationDtoApiResponseDto implements IParticipationDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: ParticipationDto;
    errors?: string[] | undefined;

    constructor(data?: IParticipationDtoApiResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"] ? ParticipationDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ParticipationDtoApiResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipationDtoApiResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IParticipationDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: ParticipationDto;
    errors?: string[] | undefined;
}

export class ParticipationDtoPagedResultDto implements IParticipationDtoPagedResultDto {
    items?: ParticipationDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    readonly totalPages?: number;
    readonly hasNextPage?: boolean;
    readonly hasPreviousPage?: boolean;

    constructor(data?: IParticipationDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ParticipationDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            (<any>this).totalPages = _data["totalPages"];
            (<any>this).hasNextPage = _data["hasNextPage"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
        }
    }

    static fromJS(data: any): ParticipationDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipationDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasNextPage"] = this.hasNextPage;
        data["hasPreviousPage"] = this.hasPreviousPage;
        return data;
    }
}

export interface IParticipationDtoPagedResultDto {
    items?: ParticipationDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;
    hasPreviousPage?: boolean;
}

export class ParticipationDtoPagedResultDtoApiResponseDto implements IParticipationDtoPagedResultDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: ParticipationDtoPagedResultDto;
    errors?: string[] | undefined;

    constructor(data?: IParticipationDtoPagedResultDtoApiResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"] ? ParticipationDtoPagedResultDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ParticipationDtoPagedResultDtoApiResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipationDtoPagedResultDtoApiResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IParticipationDtoPagedResultDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: ParticipationDtoPagedResultDto;
    errors?: string[] | undefined;
}

export class ParticipationSummaryDto implements IParticipationSummaryDto {
    participationId?: number;
    userName?: string | undefined;
    userProfileImage?: string | undefined;
    status?: string | undefined;
    participationDate?: Date;
    notes?: string | undefined;

    constructor(data?: IParticipationSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.participationId = _data["participationId"];
            this.userName = _data["userName"];
            this.userProfileImage = _data["userProfileImage"];
            this.status = _data["status"];
            this.participationDate = _data["participationDate"] ? new Date(_data["participationDate"].toString()) : <any>undefined;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): ParticipationSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipationSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["participationId"] = this.participationId;
        data["userName"] = this.userName;
        data["userProfileImage"] = this.userProfileImage;
        data["status"] = this.status;
        data["participationDate"] = this.participationDate ? this.participationDate.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IParticipationSummaryDto {
    participationId?: number;
    userName?: string | undefined;
    userProfileImage?: string | undefined;
    status?: string | undefined;
    participationDate?: Date;
    notes?: string | undefined;
}

export class ParticipationSummaryDtoPagedResultDto implements IParticipationSummaryDtoPagedResultDto {
    items?: ParticipationSummaryDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    readonly totalPages?: number;
    readonly hasNextPage?: boolean;
    readonly hasPreviousPage?: boolean;

    constructor(data?: IParticipationSummaryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ParticipationSummaryDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            (<any>this).totalPages = _data["totalPages"];
            (<any>this).hasNextPage = _data["hasNextPage"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
        }
    }

    static fromJS(data: any): ParticipationSummaryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipationSummaryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasNextPage"] = this.hasNextPage;
        data["hasPreviousPage"] = this.hasPreviousPage;
        return data;
    }
}

export interface IParticipationSummaryDtoPagedResultDto {
    items?: ParticipationSummaryDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;
    hasPreviousPage?: boolean;
}

export class ParticipationSummaryDtoPagedResultDtoApiResponseDto implements IParticipationSummaryDtoPagedResultDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: ParticipationSummaryDtoPagedResultDto;
    errors?: string[] | undefined;

    constructor(data?: IParticipationSummaryDtoPagedResultDtoApiResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"] ? ParticipationSummaryDtoPagedResultDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ParticipationSummaryDtoPagedResultDtoApiResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipationSummaryDtoPagedResultDtoApiResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IParticipationSummaryDtoPagedResultDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: ParticipationSummaryDtoPagedResultDto;
    errors?: string[] | undefined;
}

export class StringApiResponseDto implements IStringApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: string | undefined;
    errors?: string[] | undefined;

    constructor(data?: IStringApiResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): StringApiResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new StringApiResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IStringApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: string | undefined;
    errors?: string[] | undefined;
}

export class UpdateEventDto implements IUpdateEventDto {
    title?: string | undefined;
    description?: string | undefined;
    eventDate?: Date | undefined;
    registrationDeadline?: Date | undefined;
    locationName?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;
    maxParticipants?: number | undefined;
    cost?: number | undefined;
    additionalInfo?: string | undefined;
    status?: string | undefined;

    constructor(data?: IUpdateEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.description = _data["description"];
            this.eventDate = _data["eventDate"] ? new Date(_data["eventDate"].toString()) : <any>undefined;
            this.registrationDeadline = _data["registrationDeadline"] ? new Date(_data["registrationDeadline"].toString()) : <any>undefined;
            this.locationName = _data["locationName"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.maxParticipants = _data["maxParticipants"];
            this.cost = _data["cost"];
            this.additionalInfo = _data["additionalInfo"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["description"] = this.description;
        data["eventDate"] = this.eventDate ? this.eventDate.toISOString() : <any>undefined;
        data["registrationDeadline"] = this.registrationDeadline ? this.registrationDeadline.toISOString() : <any>undefined;
        data["locationName"] = this.locationName;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["maxParticipants"] = this.maxParticipants;
        data["cost"] = this.cost;
        data["additionalInfo"] = this.additionalInfo;
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdateEventDto {
    title?: string | undefined;
    description?: string | undefined;
    eventDate?: Date | undefined;
    registrationDeadline?: Date | undefined;
    locationName?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;
    maxParticipants?: number | undefined;
    cost?: number | undefined;
    additionalInfo?: string | undefined;
    status?: string | undefined;
}

export class UpdateEventTypeDto implements IUpdateEventTypeDto {
    typeName?: string | undefined;
    description?: string | undefined;
    iconName?: string | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IUpdateEventTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeName = _data["typeName"];
            this.description = _data["description"];
            this.iconName = _data["iconName"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateEventTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEventTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeName"] = this.typeName;
        data["description"] = this.description;
        data["iconName"] = this.iconName;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateEventTypeDto {
    typeName?: string | undefined;
    description?: string | undefined;
    iconName?: string | undefined;
    isActive?: boolean | undefined;
}

export class UpdateMessageDto implements IUpdateMessageDto {
    content!: string;

    constructor(data?: IUpdateMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): UpdateMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        return data;
    }
}

export interface IUpdateMessageDto {
    content: string;
}

export class UpdateParticipationDto implements IUpdateParticipationDto {
    status!: string;
    notes?: string | undefined;

    constructor(data?: IUpdateParticipationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): UpdateParticipationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateParticipationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IUpdateParticipationDto {
    status: string;
    notes?: string | undefined;
}

export class UpdateUserDto implements IUpdateUserDto {
    firstName?: string | undefined;
    lastName?: string | undefined;
    bio?: string | undefined;
    phoneNumber?: string | undefined;
    dateOfBirth?: Date | undefined;

    constructor(data?: IUpdateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.bio = _data["bio"];
            this.phoneNumber = _data["phoneNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["bio"] = this.bio;
        data["phoneNumber"] = this.phoneNumber;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUpdateUserDto {
    firstName?: string | undefined;
    lastName?: string | undefined;
    bio?: string | undefined;
    phoneNumber?: string | undefined;
    dateOfBirth?: Date | undefined;
}

export class UserDto implements IUserDto {
    userId?: number;
    username?: string | undefined;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    bio?: string | undefined;
    profileImageUrl?: string | undefined;
    dateOfBirth?: Date | undefined;
    phoneNumber?: string | undefined;
    isActive?: boolean;
    role?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.username = _data["username"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.bio = _data["bio"];
            this.profileImageUrl = _data["profileImageUrl"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.phoneNumber = _data["phoneNumber"];
            this.isActive = _data["isActive"];
            this.role = _data["role"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["username"] = this.username;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["bio"] = this.bio;
        data["profileImageUrl"] = this.profileImageUrl;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["phoneNumber"] = this.phoneNumber;
        data["isActive"] = this.isActive;
        data["role"] = this.role;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUserDto {
    userId?: number;
    username?: string | undefined;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    bio?: string | undefined;
    profileImageUrl?: string | undefined;
    dateOfBirth?: Date | undefined;
    phoneNumber?: string | undefined;
    isActive?: boolean;
    role?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
}

export class UserDtoApiResponseDto implements IUserDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: UserDto;
    errors?: string[] | undefined;

    constructor(data?: IUserDtoApiResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"] ? UserDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): UserDtoApiResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoApiResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IUserDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: UserDto;
    errors?: string[] | undefined;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
    items?: UserDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    readonly totalPages?: number;
    readonly hasNextPage?: boolean;
    readonly hasPreviousPage?: boolean;

    constructor(data?: IUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            (<any>this).totalPages = _data["totalPages"];
            (<any>this).hasNextPage = _data["hasNextPage"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
        }
    }

    static fromJS(data: any): UserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasNextPage"] = this.hasNextPage;
        data["hasPreviousPage"] = this.hasPreviousPage;
        return data;
    }
}

export interface IUserDtoPagedResultDto {
    items?: UserDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;
    hasPreviousPage?: boolean;
}

export class UserDtoPagedResultDtoApiResponseDto implements IUserDtoPagedResultDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: UserDtoPagedResultDto;
    errors?: string[] | undefined;

    constructor(data?: IUserDtoPagedResultDtoApiResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"] ? UserDtoPagedResultDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): UserDtoPagedResultDtoApiResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResultDtoApiResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IUserDtoPagedResultDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: UserDtoPagedResultDto;
    errors?: string[] | undefined;
}

export class UserProfileDto implements IUserProfileDto {
    userId?: number;
    username?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    bio?: string | undefined;
    profileImageUrl?: string | undefined;
    dateOfBirth?: Date | undefined;
    eventsCreated?: number;
    eventsAttended?: number;
    friendsCount?: number;
    isFriend?: boolean;
    createdAt?: Date;

    constructor(data?: IUserProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.username = _data["username"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.bio = _data["bio"];
            this.profileImageUrl = _data["profileImageUrl"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.eventsCreated = _data["eventsCreated"];
            this.eventsAttended = _data["eventsAttended"];
            this.friendsCount = _data["friendsCount"];
            this.isFriend = _data["isFriend"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["username"] = this.username;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["bio"] = this.bio;
        data["profileImageUrl"] = this.profileImageUrl;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["eventsCreated"] = this.eventsCreated;
        data["eventsAttended"] = this.eventsAttended;
        data["friendsCount"] = this.friendsCount;
        data["isFriend"] = this.isFriend;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUserProfileDto {
    userId?: number;
    username?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    bio?: string | undefined;
    profileImageUrl?: string | undefined;
    dateOfBirth?: Date | undefined;
    eventsCreated?: number;
    eventsAttended?: number;
    friendsCount?: number;
    isFriend?: boolean;
    createdAt?: Date;
}

export class UserProfileDtoApiResponseDto implements IUserProfileDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: UserProfileDto;
    errors?: string[] | undefined;

    constructor(data?: IUserProfileDtoApiResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"] ? UserProfileDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): UserProfileDtoApiResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileDtoApiResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IUserProfileDtoApiResponseDto {
    success?: boolean;
    message?: string | undefined;
    data?: UserProfileDto;
    errors?: string[] | undefined;
}

export class ApiException extends Error {
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super(message);
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}